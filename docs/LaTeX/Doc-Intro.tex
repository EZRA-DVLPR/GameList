\section{Introduction}

\subsection{Purpose of this document}
This document serves as a resource for other developers to navigate
and improve their understanding of the structure and inner workings
of the software. This document gets technical about details such as API, Data
Structures, Database Schema, and more.
If you are instead looking for the User-Friendly Manual, then
please refer to
\href{https://github.com/EZRA-DVLPR/GameList/blob/main/docs/PDF/Manual.pdf}{this
document}. By reading this document, the goal is to familiarize the reader with
the inner workings of the software.

This document was created to share the reasoning behind the design
choices across the entire
application from the various aspects including but not limited to:
\begin{itemize}
	\item APIs (or lack thereof \dots)
	\item Data Structures
	\item Security
	\item System Design
	\item UI/UX
\end{itemize}

Often, I find that the software I see online has limited comments, no
documentation, and no blog/location where the creator(s) have shared
why they made the design choices they made.
My goal is to not only show the project that I've made, but also to
provide reasoning behind the design choices made
when writing this software in particular. By providing this documentation, I
believe it would be a great asset for
developers who may be inspired by similar projects and be able to
come up to speed much more quickly as opposed as to looking through
outdated forums, libraries, and the like.
Also, it can show other developers how helpful
documentation is and why it is needed for larger projects.

Despite this being a technical document, I try my best to be as
transparent and somewhat funny/entertaining. If you enjoy my writing,
then I implore you to check out
\href{https://personal-website-ezra-dvlpr.vercel.app/blog}{my blog.}
Without further ado, I will now explain probably the first questions
one may have.
Why did I choose to write the documentation (and manual) in \LaTeX?
Also, why did I choose to switch entirely to use Go, after having
initially started in Python?

\subsection{\LaTeX? Go? What? Why?}

\subsubsection{\LaTeX}

In the world of Mathematics and Computer Science, \LaTeX (pronounced
lah-teck) is one of
the standard tools used for writing a variety of things including
manuscripts, documentation, theses, dissertations, academic
publications, and more.
\LaTeX is a free software that is used by
many professionals in industry and academia for making documents look
clean, and have more control over the document's behavior.
Prior to college/university, the primary form of writing papers is
usually some form of Office Suite like Microsoft Word, or Works if
you're old enough for that LOL, but more recently people use online
tools such as Google Docs.
These tools may be sufficient for the task at hand, but are often
lacking in some form compared to more sophisticated pieces of software.
Many of you have probably experienced the trouble of writing an
assignment, then inserting an image and seeing all your hard work get
botched or ruined.
If there are multiple collaborators on the piece, then having
multiple people make edits simultaneously is also a challenge.

With \LaTeX you can fine-tune the options to handle pieces of the
document and how they operate together.
Separating a single document into several sub-files then compiling
them together is way easier to manage and dictate who does which portion.
Furthermore, \LaTeX is extensible with its numerous packages to
import from that offer additional or even modify existing functionality.
Of course, writing in \LaTeX means learning how to write in Markdown,
and essentially learn a new ecosystem for writing things.

In my experience, writing Math notes, as well as Computer Science
documentation, has been much more simple and easier than before.
By being able to insert functions, tables, charts, images, and more
in a simpler, faster, and modular format, I have total control over how my
document looks which can help when preparing for an exam, or looking
towards presenting the software to stakeholders
(teachers/professors). It abstracts the
difficulty of formatting, spacing, and more to allow me to do what I
came to do, which is write something.

If you are interested in trying \LaTeX for yourself,
\href{https://www.latex-project.org/get/}{see here.}
Another option is to use \href{}{Overleaf}, which is just an online
\LaTeX compiler ran in a Docker container.
Using Overleaf would probably be more similar to writing with Google
Docs as opposed to just downloading some distribution to compile
\LaTeX documents.

My last word of advice if you are new to \LaTeX. Compile multiple times.
The compiler will catch different things at each compilation and use
them for subsequent compilations of the files. The big ones that are
noticeable are references and spacing on pages.

\subsubsection{Go vs Python}

To explain why I switched to Go over Python is simple.
To put it briefly:
\begin{enumerate}
	\item Go was a new language I had wanted to try making something with.
	\item Python proved unfun to debug and export the program from.
\end{enumerate}

Go (sometimes called GoLang) is a language I had never worked in
before. I had wanted to
learn a new language that would be fun to try and make something
in. The big two choices were Rust and Go. Between the two I chose Go because
I felt it was a friendlier (easier) language to jump into. I also
debated using C++ since it had a strong history of being used for
software, but decided to not use it because I couldn't
get simple \href{https://www.qt.io/product/framework}{QT}
programs to compile. Skill Issue on my end which I own up to.

As an aside, I had always expected myself to be a Rustacean
(developer who uses Rust) before a
Gopher (developer who uses Go). Alas, I am happy to say I had a
lovely time writing in Go,
even with its quirks. I love the mascot too, it's so cute and derpy.
I love collecting and seeing the images of the
\href{https://go.dev/blog/gopher}{Go gopher}
because it just brings a smile to my face seeing the little fella.
This is a major contrast to the snakes that form the Python logo.
They aren't bad, but they definitely aren't as cute.

Python had served me well before when I initially started the
project, but proved to be a hassle to work with when trying to
export. Having completed the basic functionality (with many bugs) I
attempted to make a release beforehand and couldn't figure it out.
Skill Issue on my part (again), that I handled by taking an extended break
from the project.
Hopping back onto this project, I was curious as to what went
wrong. I tried to compile and make an executable which proved more
difficult than anticipated. My goal was to share this software with
people, but if they couldn't even understand how to use it, then
they wouldn't. Then I saw other ways to export, with the main one
being Python's QT.
Having had an extremely poor experience with QT, I decided to just
abandon Python altogether and try it in a new language.

\subsection{Why make this Program?}

I often find myself wanting to knock another game off of the gaming
backlog, but see the massive list and feel unsure as to which to play
next. One key factor that weighs into whether I will select a
particular game will be the time it takes to complete it. For
example, to complete a game in 10 hours would be more desirable for a
single week experience vs an 80+ hour game which would probably last
several weeks to months. This information would make selecting a game
to remove from the backlog much easier.

Furthermore, I don't want to always have to go to
\href{https://howlongtobeat.com/}{howlongtobeat} (HLTB) and search for my game,
then compare it to others that I then have to search as well. This
process could take several minutes at a time, depending on how many
games I want to compare. I want a single point of information of
games and their times to complete, so that I can hold the information
that caters to me as an individual based on my owned games.

TLDR;
I want an individualized set of data that contains relevant
information to the games that I have/own with information on the
relative time to complete the game. This would help me clear
the backlog a lot easier.

My solution was to create a piece of software that is platform
independent that allows you to keep track of how long it takes to
complete a game in your library. This should include any game from
any library as well as user input games. The data should be retrieved
from HLTB and other websites that may offer the same information.
This program must have the following qualities:

\begin{itemize}
	\item Able to export to a variety of other programs should the user
		wish to share, or view the data in their preferred program such as
		excel, obsidian, etc.
	\item Be updated with more recent data if user desires (online
		lookup for information from sources)
	\item Customizable with different colored themes with Light/Dark
		themes as a base
	\item Easy to use
	\item Favorite games to be sorted towards the top always
	\item GUI (to see changes in real time. also user-friendly)
	\item Have a guide on how to use the software application
	\item Integrate into as many game services as I was able to do.
		Currently, that is 4 with: GOG, Steam, Epic, and PSN.
	\item Lightweight, efficient and fast data storage, modification, and retrieval
	\item Platform agnostic for desktop (macOS, Linux, and Windows)
\end{itemize}

Fun fact: While researching for this project, other similar
projects lacked the ability to extract information from Epic.
Proving to do that was rather challenging. Mine remains one of the
few to do so and if you are curious how it does it, then I suggest
you read section \ref{subsubsec:EpicInt}.

Another thing to compare this program to others similar to it, is
that they lack a GUI. Most are CLI tools that do something somewhat similar.
What I wanted was a GUI application that did what it was supposed to,
and did it well. No bloated stuff or extra features that aren't
directly enhancing the user experience (UX).

\subsection{Tech Stack}

The program is written entirely in Go. I try to always use main
libraries provided from the developers of the language as opposed to
importing so many libraries. Knowing when to leverage tasks to external
libraries is difficult to determine, but I try to stick to this guideline:
"If it isn't critical to the business/project/task at hand or would be
too much effort/time to put into making yourself, then import it."
Instead of trying to recreate a complex thing like chromedp, I would
much rather just import it and use it since the developers behind it
probably have a better understanding of the problem than me.
I just need it to connect to the endpoint and then give me the information.

For the UI, I chose to use Fyne because it is the first framework
that I got to work with a minimal example for a program. It also had
some powerful tools to package which would prove useful later.

The scraping processes use \href{http://go-colly.org/docs/}{Colly}
and \href{https://pkg.go.dev/github.com/chromedp/chromedp}{Chromedp}.
Colly is used for scraping data from a page, while Chromedp is used
to create headless chrome instances that make connections to the
websites and return the contents of the page from the JS that loads.
All other non-JS loaded content is obtained using the built-in
\href{https://pkg.go.dev/net/http}{net/http} package.

The Database is built and maintained using
\href{https://www.sqlite.org/index.html}{SQLite}. It is powerful
because it's based off of SQL, but is extremely portable and easier to manage.
SQLite is serverless and lightweight, which make it a perfect fit
into the project.

To connect to the database through code, I used the
\href{https://pkg.go.dev/github.com/mattn/go-sqlite3}{go-sqlite3} package.
To make the sql statements and process smoother (since SQLite uses
SQL), I used the \href{https://pkg.go.dev/database/sql}{database/sql}
package as well.

Because of the import/export options, I also import the
\href{https://pkg.go.dev/encoding/csv}{encoding/csv} and the
\href{https://pkg.go.dev/bufio}{bufio} packages.
The bufio package is used to read the text file contents through the
usage of a scanner which just goes line by obtaining the data,
similar to the way
\href{https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html}{Java
reads files.}

To manage the color themes that users may want to use, create, or
modify, I decided to use YAML. This is because YAML simplifies the
process of importing, reading, and writing the data.
It's also easy to read and simple enough
for non-developer users to modify should they want to. Of course this means that
they have to make their own YAML file and insert it into the
\textit{themes} directory, but if they are willing to do that,
then they should have some level of computer literacy.
The \href{https://pkg.go.dev/gopkg.in/yaml.v3}{yaml.v3} package is
the one that deals with the YAML files.

\subsection{RNG}

There are parts where the program determines an action based on
randomness. As well known in computer science, there is no easy way
to generate truly random numbers,
\href{https://www.freecodecamp.org/news/true-randomness-in-software-engineering/}{see
here} for more information. For the purpose of this project,
true randomness is not necessary to achieve the intended affect. As a
result, there is no need to implement more entropy. Furthermore,
there is no need to implement a seed for reproducing the randomly
generated results.

\subsection{Storing/Inputting User Information}

There are pieces of this software that adjust to user preferences.
These include functionality such as storing the previously used
window size, search preferences, and more. These settings are stored
locally within the application for an improved UX.

There are other parts of the software, namely the integrations, which
require further user input such as cookies. These are left as inputs
are NOT STORED within the program. They are used and read only once, namely
when the user is prompted. This is to assure the user that the
program won't keep this information or use it maliciously. Basically,
peace of mind.

It's important as developers to keep in mind the stakeholders (users
in this case) of the program. Considering their perspective drives
development in the UI/UX department. Being able to cater to the needs
and address potential issues before they arise remains a top priority
of any program.

\subsection{Ethical considerations for scraping}

Web Scraping is the process of accessing a web page and retrieving
the information from it. Usually this is done without an API and is
the "improper" way to access the information. This is because this
creates traffic, has questionable goals, and is otherwise a concern
for ethical consideration. My intention is to explain the reasoning
behind not using official APIs and resorting to scraping the
information via websites.

First, howlongtobeat has no official API.
\href{https://howlongtobeat.com/forum/thread/807/1}{This has been a
request for several (9+) years.} This has been brought up to the
maintainer's attention but no official public API has been released
as of writing this
document. As a result, until the API is brought to the public so
developers like myself (EZRA-DVLPR) can access it, I will continue to scrape
the website for information to achieve my goals.
The situation is similar for the other services and integrations.

My main goal was to create a program that allows users to access
information for the games that they are interested in. The program
would help by listing information that is specifically catered to the user.
I believe that these intentions are pure. I have no intention to
misuse this program to block or negatively influence the associated
services. I also don't condone the usage of the program for malicious
purposes. It isn't right nor fair to the hard workers of these
services to abuse the systems they have created. My goal is to keep
things as clean as possible. To that extent, I hope to update the way
the program runs should there be an updated API with proper and
legible documentation.

Should you disagree and believe that this program is harmful and
hurtful to the developers and providers to the services that this
program uses, then feel free to not use it. I respect your decision :)
